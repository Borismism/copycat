"""
Channel Risk Calculator - 5-Factor Scoring (0-100)

Calculates channel-level risk based on historical infringement behavior.
This score represents 40% of the final scan priority.
"""

import logging
from datetime import datetime, timezone

logger = logging.getLogger(__name__)


class ChannelRiskCalculator:
    """
    Calculate channel risk score (0-100) based on 5 factors.

    Factors:
    1. Infringement History (0-40 pts) - Past behavior predicts future
    2. Total Infringing Views (0-25 pts) - Scale of damage
    3. Channel Activity (0-20 pts) - Posting frequency
    4. Channel Size (0-10 pts) - Potential reach
    5. Last Infringement Recency (0-5 pts) - Urgency
    """

    def calculate_channel_risk(self, channel: dict) -> dict:
        """
        Calculate comprehensive channel risk score.

        Args:
            channel: Channel document from Firestore

        Returns:
            {
                "channel_risk": int (0-100),
                "factors": {
                    "infringement_history": int,
                    "total_infringing_views": int,
                    "channel_activity": int,
                    "channel_size": int,
                    "last_infringement_recency": int
                }
            }
        """
        channel_id = channel.get("channel_id", "unknown")

        factors = {
            "infringement_history": self._calculate_infringement_history_score(channel),
            "total_infringing_views": self._calculate_infringing_views_score(channel),
            "channel_activity": self._calculate_channel_activity_score(channel),
            "channel_size": self._calculate_channel_size_score(channel),
            "last_infringement_recency": self._calculate_last_infringement_recency_score(channel),
        }

        # Sum all factors (max 100)
        channel_risk = sum(factors.values())
        channel_risk = max(0, min(100, channel_risk))

        logger.info(
            f"Channel {channel_id}: risk={channel_risk}, factors={factors}"
        )

        return {
            "channel_risk": channel_risk,
            "factors": factors,
        }

    def _calculate_infringement_history_score(self, channel: dict) -> int:
        """
        Factor 1: Infringement history (0-40 points).

        SIMPLE RULE: INFRINGEMENT = CRITICAL (40 pts)
        Only many consecutive clean videos gradually reduce the risk.

        Scoring Logic:
        - ANY confirmed infringement found: 40 pts (CRITICAL - stays CRITICAL)
        - To reduce from 40 pts, channel needs consecutive clean scans:
          - 1-5 clean videos after infringement: 40 pts (still CRITICAL)
          - 6-10 clean videos: 38 pts (slowly improving)
          - 11-20 clean videos: 35 pts (improving)
          - 21-30 clean videos: 32 pts
          - 31-50 clean videos: 28 pts
          - 51+ clean videos: 25 pts (proven reformed, but never fully trusted)

        - IF NO infringements ever found:
          - 0 scans (UNKNOWN): 35 pts (HIGH RISK until proven otherwise)
          - 1-2 clean scans: 25 pts
          - 3-5 clean scans: 15 pts
          - 6-10 clean scans: 8 pts
          - 11+ clean scans: 3 pts (proven clean)
        """
        infringement_count = channel.get("infringing_videos_count", 0)
        videos_scanned = channel.get("videos_scanned", 0)
        videos_cleared = channel.get("videos_cleared", 0)  # Clean videos found

        if infringement_count > 0:
            # INFRINGEMENT FOUND = CRITICAL
            # Only gradual improvement with many clean videos AFTER infringement
            # Use videos_cleared as proxy for "clean since infringement"
            if videos_cleared <= 5:
                return 40  # CRITICAL - stays critical
            elif videos_cleared <= 10:
                return 38  # Slowly improving
            elif videos_cleared <= 20:
                return 35  # Improving
            elif videos_cleared <= 30:
                return 32
            elif videos_cleared <= 50:
                return 28
            else:
                return 25  # Proven reformed (but never fully trusted)
        else:
            # No infringements YET - score by how many clean scans
            # UNKNOWN = ASSUME RISKY until proven otherwise!
            if videos_scanned == 0:
                return 35  # UNKNOWN = HIGH RISK
            elif videos_scanned <= 2:
                return 25
            elif videos_scanned <= 5:
                return 15
            elif videos_scanned <= 10:
                return 8
            else:
                return 3  # Proven clean

    def _calculate_infringing_views_score(self, channel: dict) -> int:
        """
        Factor 2: Total infringing views (0-25 points).

        High-view infringements = massive damage to IP.

        Scoring:
        - 0 views: 0 pts
        - 1k-10k: 5 pts
        - 10k-100k: 10 pts
        - 100k-1M: 15 pts
        - 1M-10M: 20 pts
        - 10M+: 25 pts (MEGA VIRAL)
        """
        total_views = channel.get("total_infringing_views", 0)

        if total_views == 0:
            return 0
        elif total_views < 10_000:
            return 5
        elif total_views < 100_000:
            return 10
        elif total_views < 1_000_000:
            return 15
        elif total_views < 10_000_000:
            return 20
        else:
            return 25

    def _calculate_channel_activity_score(self, channel: dict) -> int:
        """
        Factor 3: Channel activity (0-20 points).

        Active channels = ongoing threat.

        Scoring:
        - Unknown (no data): 20 pts (assume active until proven otherwise!)
        - Posted in last 7 days: 20 pts (ACTIVE!)
        - Last 30 days: 15 pts
        - Last 90 days: 10 pts
        - Last 180 days: 5 pts
        - Older: 0 pts (dormant)

        Bonus: >10 videos/month: +5 pts (capped at 20)
        """
        last_upload = channel.get("last_upload_date")
        if not last_upload:
            return 20  # Unknown = assume active (risky!)

        # Handle both datetime objects and timestamps
        if isinstance(last_upload, datetime):
            last_upload_dt = last_upload
        else:
            # Assume it's already a datetime
            last_upload_dt = last_upload

        days_since_upload = (datetime.now(timezone.utc) - last_upload_dt).days

        if days_since_upload <= 7:
            base = 20
        elif days_since_upload <= 30:
            base = 15
        elif days_since_upload <= 90:
            base = 10
        elif days_since_upload <= 180:
            base = 5
        else:
            base = 0

        # Bonus for prolific channels (capped at max 20)
        videos_per_month = channel.get("videos_per_month", 0)
        bonus = 5 if videos_per_month > 10 else 0

        return min(20, base + bonus)

    def _calculate_channel_size_score(self, channel: dict) -> int:
        """
        Factor 4: Channel size (0-10 points).

        Larger channels = wider reach if infringing.

        Scoring:
        - <1k subs: 2 pts
        - 1k-10k: 4 pts
        - 10k-100k: 6 pts
        - 100k-1M: 8 pts
        - 1M+: 10 pts (HUGE reach)
        """
        subscribers = channel.get("subscriber_count", 0)

        if subscribers < 1_000:
            return 2
        elif subscribers < 10_000:
            return 4
        elif subscribers < 100_000:
            return 6
        elif subscribers < 1_000_000:
            return 8
        else:
            return 10

    def _calculate_last_infringement_recency_score(self, channel: dict) -> int:
        """
        Factor 5: Last infringement recency (0-5 points).

        Recent infringement = likely to do it again soon.

        Scoring:
        - Last 7 days: 5 pts (VERY HOT!)
        - Last 30 days: 3 pts
        - Last 90 days: 1 pt
        - Older: 0 pts
        """
        last_infringement_date = channel.get("last_infringement_date")
        if not last_infringement_date:
            return 0

        # Handle both datetime objects and timestamps
        if isinstance(last_infringement_date, datetime):
            last_inf_dt = last_infringement_date
        else:
            last_inf_dt = last_infringement_date

        days_since = (datetime.now(timezone.utc) - last_inf_dt).days

        if days_since <= 7:
            return 5
        elif days_since <= 30:
            return 3
        elif days_since <= 90:
            return 1
        else:
            return 0
